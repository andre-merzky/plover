 
   The ability to access the contents of files regardless of
   their location is central to many of the SAGA use cases.
   This section addresses the most common operations detailed
   in these use cases.
   
   It is important to note that interactions with files
   as opaque entities (i.e. as entries in file name spaces) are
   covered by the |namespace| package.  The classes presented
   here supplement the |namespace| package with operations for the
   reading and writing of the \I{contents} of files.  For all
   methods, the descriptions and notes of the equivalent methods
   in the |namespace| package apply if available, unless noted
   here otherwise.
   
   The described classes are syntactically and
   semantically POSIX
   oriented~\cite{posix1,posix2,posix3}.  Executing
   large numbers of simple POSIX-like remote data access
   operations is, however, prone to latency related
   performance problems.  To allow for efficient
   implementations, the presented API  borrows ideas from
   GridFTP and other specifications which are widely used for
   remote data access.  These extensions should be seen
   as just that: optimizations.  Implementations of this package
   MUST implement the POSIX-like |read()|, |write()| and
   |seek()| methods, and MAY implement the additional optimized
   methods (a 'NotImplemented' exception  MUST be thrown
   if these are not implemented).  The optimizations included
   here are:
 
   \paragraph{Scattered I/O}
   
   Scattered I/O operations are already defined by POSIX, as
   |readv()| and |writev()|.  Essentially, these methods
   represent \B{v}ector versions of the standard POSIX
   |read()/write()| methods; the arguments are,
   basically,  vectors of instructions to
   execute, and buffers to operate upon.  In other
   words, |readv()| and |writev()| can be regarded as
   specialized bulk methods, which cluster multiple I/O
   operations into a single operation.  Advantage of such an
   approach are that it is easy to implement, is very close to
   the original POSIX I/O in semantics, and in some cases even
   very fast.  Disadvantages are that for many small I/O
   operations (a common occurrence in SAGA use cases), the
   description of the I/O operations can be larger than the
   sent, returned or received data.
 
   \paragraph{Pattern-Based I/O (FALLS)}
   
   One approach to address the bandwidth limitation of scattered
   I/O is to describe the required I/O operations at a more
   abstract level.  Regularly repeating patterns of binary data
   can be described by the so-called 'Family of Line Segments'
   (FALLS)~\cite{falls}.  The pattern-based I/O routines in SAGA
   use such descriptions to reduce the bandwidth limitation of
   scattered I/O.  The advantage of such an approach is
   that it targets very common data access patterns (at least
   those very commonly found in SAGA use cases).  The
   disadvantages are that FALLS is a paradigm not widely known
   or used, and that FALLS is by definition, limited to regular
   patterns of data, and hence is inefficient for more
   randomized data access.
 
    \mywfig{r}{0.45}{falls}{\footnotesize The highlighted
    elements are defined by \T{"(0,17,36,6,(0,0,2,6))"}.}
 
   FALLS (FAmiLy of Line Segments) were originally introduced
   for transformations in parallel computing. There is also a
   parallel filesystem which uses FALLS to describe the file
   layout. They can be used to describe regular subsets of
   arrays with a very compact syntax.  
   
   FALLS pattern are formed as 5-tuples:
   |"(from,to,stride,rep,(pat))"|.  The |from| element defines
   the starting offset for the first pattern unit, |to| defines
   the finishing offset of the first pattern unit, |stride|
   defines the distance between consecutive pattern units (begin
   to begin), and |rep| defines the number of repetitions of the
   pattern units.  The optional 5th element |pat| allows the
   definition of nested patterns, where the internal
   pattern defines the unit the outer pattern is applied to (by
   default that is one byte).  As an example: the following
   FALLS describe the highlighted elements of the matrix in
   Fig~\ref{fig:falls}: |"(0,17,36,6,(0,0,2,6))"|: the inner
   pattern describes a pattern unit of one byte length (from 0
   to 0), with a distance of 2 to the next application, and 6
   repetitions.  These are the 6 bytes per line which are
   marked.  The outer pattern defines the repeated
   application of the inner pattern, starting at 0, ending at 17
   (end of line), distance of 36 (to begin of next but one
   line), and repetition of 6.
 
 
   \paragraph{Extended I/O}
   
   GridFTP (which was designed for a similar target domain)
   introduced an additional remote I/O paradigm, that of
   Extended I/O operations.
   
   In essence, the Extended I/O paradigm allows the formulation
   of I/O requests using custom strings, which are not
   interpreted on the client but on the server side; these can
   be expanded to arbitrarily complex sets of I/O
   operations.  The type of I/O request encoded in the string is
   called |mode|.  A server may support one or many of these
   extended I/O modes.  Whereas the approach is very flexible
   and powerful and has proven its usability in GridFTP, a
   disadvantage is that it requires very specific infrastructure
   to function, i.e. it requires a remote server instance which
   can interpret opaque client requests.  Additionally, no
   client side checks or optimizations on the I/O requests are
   possible.  Also, the application programmer needs to estimate
   the size of the data to be returned in advance, which in some
   cases is very difficult.\\
   
   The three described operations have, if compared to each
   other, increasing semantic flexibility, and are increasingly
   powerful for specific use cases.  However, they are also
   increasingly difficult to implement and support in a generic
   fashion.  It is up to the SAGA implementation and the
   specific use cases, to determine the level of I/O abstraction
   that serves the application best and that can be best
   supported in the target environment.
 
 
 \subsubsection{Specification}
 
 \begin{myspec}
  package saga.file 
  { 
    enum flags 
    { 
      None           =    0, // same as in saga::namespace::flags 
      Overwrite      =    1, // same as in saga::namespace::flags
      Recursive      =    2, // same as in saga::namespace::flags 
      Dereference    =    4, // same as in saga::namespace::flags 
      Create         =    8, // same as in saga::namespace::flags 
      Exclusive      =   16, // same as in saga::namespace::flags
      Lock           =   32, // same as in saga::namespace::flags 
      CreateParents  =   64, // same as in saga::namespace::flags 
      Truncate       =  128, 
      Append         =  256, 
!     Read           =  512, // same as in saga::namespace::flags 
!     Write          = 1024, // same as in saga::namespace::flags 
!     ReadWrite      = 1536, // same as in saga::namespace::flags 
      Binary         = 2048 
    }
 
 
    enum seek_mode
    {
      Start      =   1,
      Current    =   2,
      End        =   3
    }
 
 
    class iovec : extends     saga::core::buffer
               // from buffer saga::core::object
               // from object saga::core::error_handler
    {
      CONSTRUCTOR (in array<byte>          data   = "",
                   in    int               size   = 0,
                   in    int               offset = 0,
                   in    int               len_in = size,
                   out   iovec             obj);
      DESTRUCTOR  (in    iovec             obj);
 
      set_offset  (in    int               offset);
      get_offset  (out   int               offset);
 
      set_len_in  (in    int               len_in);
      get_len_in  (out   int               len_in);
 
      get_len_out (out   int               len_out);
    }
 
    class file : extends        saga::namespace::ns_entry
              // from ns_entry  saga::core::object
              // from ns_entry  saga::core::async
              // from ns_entry  saga::core::permissions
              // from object    saga::core::error_handler
    {
      CONSTRUCTOR (in    session           s,
                   in    url               name,
                   in    int               flags = Read,
                   out   file              obj      );
      DESTRUCTOR  (in    file              obj      );
 
      // inspection
      get_size    (out   int               size     );
 
      // POSIX-like I/O
      read        (inout buffer            buf,
                   in    int               len_in = -1,
                   out   int               len_out  );
      write       (in    buffer            buf,
                   in    int               len_in = -1,
                   out   int               len_out  );
      seek        (in    int               offset,
                   in    seek_mode         whence,
                   out   int               position );
 
      // scattered I/O
      read_v      (inout array<iovec>      iovecs  );
      write_v     (inout array<iovec>      iovecs  );
 
      // pattern-based I/O
      size_p      (in    string            pattern,
                   out   int               size     );
      read_p      (in    string            pattern,
                   inout buffer            buf, 
                   out   int               len_out  );
      write_p     (in    string            pattern,
                   in    buffer            buf, 
                   out   int               len_out  );
 
      // extended I/O
      modes_e     (out   array<string>     emodes   );
      size_e      (in    string            emode,
                   in    string            spec,
                   out   int               size     );
      read_e      (in    string            emode,
                   in    string            spec,
                   inout buffer            buf,
                   out   int               len_out  );
      write_e     (in    string            emode,
                   in    string            spec,
                   in    buffer            buf,
                   out   int               len_out  );
    }
 
 
    class directory : extends            saga::namespace::ns_directory
                   // from ns_directory  saga::namespace::ns_entry
                   // from ns_entry      saga::core::object
                   // from ns_entry      saga::core::async
                   // from ns_entry      saga::core::permissions
                   // from object        saga::core::error_handler
    {
      CONSTRUCTOR (in    session           s,
                   in    url               name,
                   in    int               flags = Read,
                   out   directory         obj      );
      DESTRUCTOR  (in    directory         obj      );
 
      // inspection methods
      get_size    (in    url               name,
                   in    int               flags = None,
                   out   int               size     );
      is_file     (in    url               name,
                   in    int               flags = None,
                   out   boolean           test     );
 
      // factory-like methods
      open_dir    (in    url               name,
                   in    int               flags = Read,
                   out   directory         dir      );
 
      open        (in    url               name,
                   in    int               flags = Read,
                   out   file              file     );
    }
  }
 \end{myspec}
 
 
 \subsubsection{Specification Details}
 
  \subsubsection*{Enum \T{flags}}
 
  The \T{flags} enum is inherited from the
  \T{namespace} package.  A number of file specific flags are
  added to it.  All added flags are used for the opening of
  \T{file} and \T{directory} instances, and are not applicable
  to the operations inherited from the \T{namespace} package.
  
    |Truncate|\\[0.3mm]
    \begin{tabular}{cp{110mm}}
      ~~ & Upon opening, the file is truncated to length 
           \T{0}, i.e. a following \T{read()} operation will 
           never find any data in the file.  That flag does not 
           apply to directories.
    \end{tabular}
 
    |Append|\\[0.3mm]
    \begin{tabular}{cp{110mm}}
      ~~ & Upon opening, the file pointer is set to the 
           end of the file, i.e. a following \T{write()} 
           operation will extend the size of the file.  That 
           flag does not apply to directories.
    \end{tabular}
 
    \XRem{Read, Write and ReadWrite flags are moved to namespace.}
  % |Read|\\[0.3mm]
  % \begin{tabular}{cp{110mm}}
  %   ~~ & The file or directory is opened for reading 
  %        -- that does not imply the ability to write to the 
  %        file or directory.
  % \end{tabular}
  %
  % |Write|\\[0.3mm]
  % \begin{tabular}{cp{110mm}}
  %   ~~ & The file or directory is opened for writing 
  %        -- that does not imply the ability to read from the 
  %        file or directory.
  % \end{tabular}
  %
  % |ReadWrite|\\[0.3mm]
  % \begin{tabular}{cp{110mm}}
  %   ~~ & The file or directory is opened for reading 
  %        and writing.
  % \end{tabular}
  %
  % |Binary|\\[0.3mm]
  % \begin{tabular}{cp{110mm}}
  %   ~~ & Some operating systems (notably windows 
  %        based systems) distinguish between binary and 
  %        non-binary modes -- this flag mimics that behavior.
  % \end{tabular}
 
 
  \subsubsection*{Class \T{iovec}}
 
    The \T{iovec} class inherits the \T{saga::buffer}
    class, and three additional state attributes: \T{offset},
    \T{len\_in} and \T{len\_out} (with the latter one being
    read-only).  With that addition, the new class can be used
    very much the same way as the \T{iovec} structure defined by
    POSIX for \T{readv}/\T{writev}, with the buffer \T{len\_in}
    being interpreted as the POSIX \T{iov\_len}, i.e. the
    number of bytes to read/write.
 
    If \T{len\_in} is not specified, that length is set
    to the size of the buffer.  It is a \T{BadParameter} error
    if \T{len\_in} is specified to be larger than size, for
    application managed buffers (see Section~\ref{ssec:buffer}
    for details on buffer memory management).  Before an
    \T{iovec} instance is used, it's \T{len\_in} MUST be set to
    a non-zero value; otherwise it's use will cause a
    \T{BadParameter} exception.
 
    After a \T{read\_v()} or \T{write\_v()} operations
    completes, \T{len\_out} will report the number of bytes
    read.  Before completion, the SAGA implementation MUST
    report \T{len\_out} to be \T{-1}.
 
 
 \begin{myspec}
    - CONSTRUCTOR
      Purpose:  create an iovec instance
      Format:   CONSTRUCTOR     (in  array<byte> data   = "",
                                 in  int         size   = -1,
                                 in  int         offset = 0,
                                 in  int         len_in = size,
                                 out iovec       obj);
      Inputs:   type:                 data to be used
                size:                 size of data to be used
                offset                offset for I/O operation
                len_in:               number of bytes to read
                                      or write on read_v/write_v
      InOuts:   -
      Outputs:  obj:                  the newly created iovec 
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   BadParameter
                NoSuccess
      Notes:    - all notes from the buffer CONSTRUCTOR apply.
                - if len_in is larger than size, and size is 
                  not given as -1, a 'BadParameter' exception 
                  is thrown.
 
    - DESTRUCTOR
      Purpose:  destroy an iovec instance
      Format:   DESTRUCTOR           (in  iovec obj);
      Inputs:   obj:                  the iovec to destroy
      InOuts:   -
      Outputs:  -
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   - 
      Notes:    - all notes from the buffer DESTRUCTOR apply.
 
    - set_offset
      Purpose:  set offset
      Format:   set_offset           (in  int   offset);
      Inputs:   offset:               value for offset
      InOuts:   -
      Outputs:  -
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   BadParameter
      Notes:    - if offset is smaller that zero, a 
                  'BadParameter' exception is thrown.
 
    - get_offset
      Purpose:  retrieve the current value for offset
      Format:   get_offset           (out int   offset);
      Inputs:   -
      InOuts:   -
      Outputs:  offset:               value of offset
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   -
      Notes:    -
 
    - set_len_in
      Purpose:  set len_in
      Format:   set_len_in           (in  int   len_in);
      Inputs:   len_in:               value for len_in
      InOuts:   -
      Outputs:  -
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   BadParameter
      Notes:    - if len_in is larger than size, and size is 
                  not set to -1, a 'BadParameter' exception 
                  is thrown.
 
    - get_len_in
      Purpose:  retrieve the current value for len_in
      Format:   get_len_in           (out int   len_in);
      Inputs:   -
      InOuts:   -
      Outputs:  len_in:               value of len_in
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   -
      Notes:    -
 
    - get_len_out
      Purpose:  retrieve the value for len_out
      Format:   get_len_out          (out int   len_out);
      Inputs:   -
      InOuts:   -
      Outputs:  len_out:              value of len_out
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   -
      Notes:    - len_out reports the number of bytes read
                  or written in a completed read_w or write_w
                  operation.
                - before completion of the operation, the
                  returned value is -1.
                - for implementation managed memory, the 
                  value of len_out is always the same as 
                  for size.
 \end{myspec}
 
 
  \subsubsection*{Class \T{file}}
 
    This class represents an open file descriptor for read/write
    operations on a physical file.  Its concept is similar to
    the file descriptor returned by the |open (2)| call in
    POSIX.
 
    In language bindings where this is appropriate, several
    methods can return error codes indicating failure, instead
    of always raising an exception.  These error codes are, as
    described in Section~\ref{ssec:error}, defined as POSIX
    |errno| values.  These codes SHOULD be used in identical
    situations as described in POSIX.  The calls which can use
    return error codes are documented.

    \XAdd[5]{A file instance has specific state, which in
    general consists of the file's URL, the mode with which the
    file was opened or created, and the position of the file
    pointer used for I/O.  Note that a \T{move()} operation
    keeps the file instance and the file pointer state, but the
    other state information (URL and open mode) may change under
    \T{move()}.}
 
 
 \begin{myspec}
    - CONSTRUCTOR
      Purpose:  create the obj
      Format:   CONSTRUCTOR        (in  session   s,
                                    in  url       name,
                                    in  int       flags = Read,
                                    out file      obj)
      Inputs:   s:                  session to associate the
                                    object with
                name:               location of file
                flags:              mode for opening
      InOuts:   -
      Outputs:  obj:                the newly created object
      PreCond:  -
      PostCond: - the file is opened.
                - 'Owner' of target is the id of the context
                  use to perform the operation, if the file
                  gets created.
      Perms:    Exec  for parent directory.
                Write for parent directory if Create is set.
                Write for name if Write is set.
                Read  for name if Read  is set.
      Throws:   NotImplemented
                IncorrectURL
                BadParameter
                AlreadyExists
                DoesNotExist
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - all notes from the directory::open() method
                  apply.
                - the default flags are 'Read' (512).
 
 
    - DESTRUCTOR
      Purpose:  destroy the object
      Format:   DESTRUCTOR         (in  file      obj)
      Inputs:   obj:                the object to destroy
      InOuts:   -
      Outputs:  -
      PreCond:  -
      PostCond: - the file is closed.
      Perms:    - 
      Throws:   - 
      Notes:    - the semantics of the inherited destructors
                  apply
 
 
    additional inspection methods:
    ------------------------------
 
    - get_size
      Purpose:  returns the number of bytes in the file
      Format:   get_size           (out int     size);
      Inputs:   -
      InOuts:   -
      Outputs:  size:               number of bytes in the file
      PreCond:  -
      PostCond: -
      Perms:    Query
      Throws:   NotImplemented
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - similar to the 'st_size' field from 'stat' (2)
                  as defined by POSIX
 
 
    POSIX-like I/O methods:
    -----------------------
 
    - read
      Purpose:  reads up to len_in bytes from the file into
                the buffer.
      Format:   read               (inout buffer      buf,
                                    in    int         len_in = -1,
                                    out   int         len_out);
      Inputs:   len_in:             number of bytes to be read
      InOuts:   buf:                buffer to read data into
      Outputs:  len_out:            number of bytes successfully 
                                    read
      PreCond:  -
      PostCond: - the data from the file are available in the
                  buffer.
      Perms:    Read
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - the actual number of bytes read into buffer
                  is returned in len_out.  It is not an error
                  to read less bytes than requested, or in fact
                  zero bytes, e.g. at the end of the file.
                - errors are indicated by returning negative
                  values for len_out, which correspond to
                  negatives of the respective POSIX ERRNO error
                  code.
                - the file pointer is positioned at the end of
                  the byte area successfully read during this 
                  call.
                - the given buffer must be large enough to
                  store up to len_in bytes, or managed by the
                  implementation - otherwise a 'BadParameter'
                  exception is thrown.
                - the notes about memory management from the
                  buffer class apply.
                - if the file was opened in write-only mode (i.e.
                  no 'Read' or 'ReadWrite' flag was given), this
                  method throws an 'PermissionDenied' exception.
                - if len_in is smaller than 0, or not given, 
                  the buffer size is used for len_in.
                  If that is also not available, a
                  'BadParameter' exception is thrown.
                - similar to read (2) as specified by POSIX
 
 
    - write
      Purpose:  writes up to len_in bytes from buffer into
                the file at the current file position.
      Format:   write              (in  buffer      buf,
                                    in  int         len_in = -1,
                                    out int         len_out);
      Inputs:   len_in:             number of bytes to write
                buf:                buffer to write data from
      InOuts:   -
      Outputs:  len_out:            number of bytes successfully
                                    written
      PreCond:  -
      PostCond: - the buffer data are written to the file.
      Perms:    Write
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - errors are indicated by returning negative
                  values for len_out, which correspond to
                  negatives of the respective POSIX ERRNO error 
                  code.
                - the file pointer is positioned at the end
                  of the byte area written during this call.
                - if the file was opened in read-only mode (i.e.
                  no 'Write' or 'ReadWrite' flag was given), this
                  method throws an 'PermissionDenied' exception.
                - the given buffer must hold enough data to
                  write - otherwise, only the available data
                  will be written, and and len_out will be set
                  to the number of bytes written.
                - the notes about memory management from the
                  buffer class apply.
                - if len_in is smaller than 0, or not given, 
                  the buffer size is used for len_in.
                  If that is also not available, a
                  'BadParameter' exception is thrown.
                - if data are written beyond the current end of
                  file, the intermediate gap is filled with '\0'
                  bytes.
                - similar to write (2) as specified by POSIX
 
 
    - seek
      Purpose:  reposition the file pointer
      Format:   seek               (in  int        offset,
                                    in  seek_mode  whence,
                                    out int        position);
      Inputs:   offset:             offset in bytes to move
                                    pointer
                whence:             offset is relative to
                                    'whence'
      InOuts:   -
      Outputs:  position:           position of pointer after
                                    seek
      PreCond:  -
      PostCond: - the file pointer is moved to the new position.
                - following read() or write() operations use
                  that position.
      Perms:    Read or Write.
      Throws:   NotImplemented
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - seek repositions the file pointer for
                  subsequent read, write and seek calls.
                - initially (after open), the file pointer is
                  positioned at the beginning of the file,
                  unless the 'Append' flag was given - then
                  the initial position is the end of the file.
                - the repositioning is done relative to the
                  position given in 'Whence', so relative to
                  the 'Begin' or 'End' of the file, or to the
                  'Current' position.
                - errors are indicated by returning negative
                  values for len_out, which correspond to
                  negatives of the respective POSIX ERRNO error 
                  code.
                - the file pointer can be positioned after the
                  end of the file without extending it.  
                - the given offset can be positive, negative, or
                  zero.
                - note that a subsequent read at or behind the end 
                  of file returns no data.
                - similar to lseek (2) as specified by POSIX.
 
 
    Scattered I/O methods:
    ----------------------
 
    - read_v
      Purpose:  gather/scatter read
      Format:   read_v             (inout array<iovec> iovecs);
      Inputs:   -
      InOuts:   iovecs:             array of iovec structs
                                    defining start (offset) and
                                    length (len_in) of each
                                    individual read, the buffer
                                    to read into, and integer 
                                    to store result into
                                    (len_out).
      Outputs:  -
      PreCond:  -
      PostCond: - data from the file are available in the
                  iovec buffers.
      Perms:    Read
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - the behavior of each individual read is as
                  in the normal read method, and all notes from
                  the read() method apply.
                - an exception MUST be thrown if any of the
                  individual reads detects a condition which
                  would raise an exception for the normal
                  read() method.
                - the notes about memory management from the
                  buffer class apply.
!               - if for any of the given iovecs no len_in is
!                 given, then the buffer's (size - offset) is 
!                 used as len_in.  If that is also not available,
!                 a 'BadParameter' exception is thrown.
+               - if for any of the given iovecs, the of 
+                 (offset + len_in) is larger than size,  
+                 a 'BadParameter' exception is thrown.
                - if the file was opened WriteOnly, a
                  'PermissionDenied' exception is thrown.
                - similar to readv (2) as specified by POSIX
 
 
    - write_v
      Purpose:  gather/scatter write
      Format:   write_v            (inout  array<iovec> iovecs);
      Inputs:   -
      InOuts:   iovecs:             array of iovec structs
                                    defining start (offset) and
                                    length (len_in) of each
                                    individual write, and
                                    buffers containing the data
                                    to write (len_out)
      Outputs:  -
      PreCond:  -
      PostCond: - the iovec buffer data are written to the file.
      Perms:    Write
      Throws:   NotImplemented
                IncorrectState
                BadParameter
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - the behavior of each individual write is as
                  in the normal write method.
                - an exception MUST be thrown if any of the
                  individual writes detects a condition which
                  would raise an exception for the normal write
                  method.
                - the notes about memory management from the
                  buffer class apply.
!               - if for any of the given iovecs no len_in is
!                 given, then the buffer's (size - offset) is 
!                 used as len_in.  If that is also not available,
!                 a 'BadParameter' exception is thrown.
+               - if for any of the given iovecs, the of 
+                 (offset + len_in) is larger than size,  
+                 a 'BadParameter' exception is thrown.
                - if the file was opened ReadOnly, a
                  'PermissionDenied' exception is thrown.
                - similar to writev (2) as specified by POSIX
 
 
    Pattern-based I/O methods:
    --------------------------
 
    - size_p
      Purpose:  determine the storage size required for a
                pattern I/O operation
      Format:   size_p             (in  string  pattern,
                                    out int     size);
      Inputs:   pattern:            pattern to determine size for
      InOuts:   -
      Outputs:  size:               size required for I/O
                                    operation with that pattern
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - the method does, in general, not perform a
                  remote operation, but is intended to help
                  the application programmer to correctly handle 
                  pattern-based I/O and associated buffer sizes.
                - if the pattern cannot be parsed or interpreted,
                  a 'BadParameter' exception is thrown.
 
 
    - read_p
      Purpose:  pattern-based read
      Format:   read_p             (in    string      pattern, 
                                    inout buffer      buf,
                                    out   int         len_out); 
      Inputs:   pattern:            pattern specification for
                                    read operation
      InOuts:   buf:                buffer to store read data
                                    into
      Outputs:  len_out:            number of successfully read
                                    bytes
      PreCond:  -
      PostCond: - data from the file are available in the
                  buffers.
      Perms:    Read
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - if the pattern cannot be parsed or interpreted,
                  a 'BadParameter' exception is thrown.
                - all notes for the read() method apply for the
                  individual reads resulting from the
                  interpretation of the pattern.
                - an exception MUST be thrown if any of the
                  individual writes detects a condition which
                  would raise an exception for the normal write
                  method.
 
 
    - write_p
      Purpose:  pattern-based read
      Format:   write_p            (in    string      pattern, 
                                    in    buffer      buf, 
                                    out   int         len_out); 
      Inputs:   pattern:            pattern specification for
                                    write operation
                buf:                buffer to be written
      InOuts:   -
      Outputs:  len_out:            number of bytes successfully
                                    written
      PreCond:  -
      PostCond: - the buffer data are written to the file.
      Perms:    Write
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - if the pattern cannot be parsed or interpreted,
                  a 'BadParameter' exception is thrown.
                - all notes for the write() method apply for the
                  individual writes resulting from the
                  interpretation of the pattern.
                - an exception MUST be thrown if any of the
                  individual writes detects a condition which
                  would raise an exception for the normal write
                  method.
 
 
    Extended I/O methods:
    ---------------------
 
    - modes_e
      Purpose:  list the extended modes available in this
                implementation, and/or on server side
      Format:   modes_e            (out array<string> emodes);
      Inputs:   -
      InOuts:   -
      Outputs:  emodes:             list of modes available for
                                    extended I/O
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   NotImplemented
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - the method does, in general, not perform a
                  remote operation, but is intended to help
                  the application programmer to determine what
                  extended I/O methods are supported by the
                  implementation.
 
 
    - size_e
      Purpose:  determine the storage size required for an
                extended I/O operation
      Format:   size_e             (in  string  emode,
                                   (in  string  spec,
                                    out int     size);
      Inputs:   emode:              extended mode to use
                spec:               specification to determine
                                    size for
      InOuts:   -
      Outputs:  size:               size required for I/O
                                    operation with that 
                                    emode/spec
      PreCond:  -
      PostCond: -
      Perms:    - 
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - the method does, in general, not perform a
                  remote operation, but is intended to help
                  the application programmer to correctly handle 
                  extended I/O and associated buffer sizes.
                - if the specification cannot be parsed or 
                  interpreted, a 'BadParameter' exception is 
                  thrown.
 
 
    - read_e
      Purpose:  extended read
      Format:   read_e             (in    string      emode, 
                                    in    string      spec, 
                                    inout buffer      buf,  
                                    out   int         len_out); 
      Inputs:   emode:              extended mode to use
                spec:               specification of read 
                                    operation
      InOuts:   buf:                buffer to store read data
                                    into
      Outputs:  len_out:            number of successfully read
                                    bytes
      PreCond:  -
      PostCond: - data from the file are available in the
                  buffers.
      Perms:    Read
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - if the emode is not supported, a 'BadParameter'
                  exception is thrown.
                - if the spec cannot be parsed or interpreted,
                  a 'BadParameter' exception is thrown.
                - all notes from the read() method apply to the
                  individual reads resulting from the
                  interpretation of the emode and spec.
                - an exception MUST be thrown if any of the
                  individual writes detects a condition which
                  would raise an exception for the normal write
                  method.
 
 
    - write_e
      Purpose:  extended write
      Format:   write_e            (in    string      emode, 
                                    in    string      spec, 
                                    in    buffer      buf,  
                                    out   int         len_out); 
      Inputs:   emode:              extended mode to use
                spec:               specification of write 
                                    operation
                buf:                buffer to store read data
                                    into
      InOuts:   -
      Outputs:  len_out:            number of bytes successfully
                                    written
      PreCond:  -
      PostCond: - the buffer data are written to the file.
      Perms:    Write
      Throws:   NotImplemented
                BadParameter
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - if the emode is not supported, a 'BadParameter'
                  exception is thrown.
                - if the spec cannot be parsed or interpreted,
                  a 'BadParameter' exception is thrown.
                - all notes from the write() method apply to the
                  individual writes resulting from the
                  interpretation of the 'emode' and 'spec'.
                - an exception MUST be thrown if any of the
                  individual writes detects a condition which
                  would raise an exception for the normal write
                  method.
 \end{myspec}
 
 
  \subsubsection*{Class \T{directory}}
 
 \begin{myspec}
    - CONSTRUCTOR
      Purpose:  open the directory
      Format:   CONSTRUCTOR        (in  session    s,
                                    in  url        name,
                                    in  int        flags = Read,
                                    out directory  obj)
      Inputs:   s:                  session to associate the
                                    object with
                name:               location of directory
                flags:              mode for opening
      InOuts:   -
      Outputs:  obj:                the newly created object
      PreCond:  -
      PostCond: - the directory is opened.
                - 'Owner' of target is the id of the context
                  use to perform the operation, if the
                  directory gets created.
      Perms:    Exec  for parent directory.
                Write for parent directory if Create is set.
                Write for name if Write is set.
                Read  for name if Read  is set.
      Throws:   NotImplemented
                IncorrectURL
                BadParameter
                AlreadyExists
                DoesNotExist
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - the default flags are 'Read' (512).
                - the semantics of the inherited constructors
                  apply
 
 
    - DESTRUCTOR
      Purpose:  destroy the directory object
      Format:   DESTRUCTOR         (in  directory obj)
      Inputs:   obj:                the object to destroy
      InOuts:   -
      Outputs:  -
      PreCond:  -
      PostCond: - the directory is closed.
      Perms:    - 
      Throws:   - 
      Notes:    - the semantics of the inherited destructors
                  apply.
 
 
    inspection methods:
    -------------------
 
    - get_size
      Purpose:  returns the number of bytes in the file
      Format:   get_size           (in  url       name,
                                    in  int       flags = None,
                                    out int       size);
      Inputs:   name:               name of file to inspect
                flags:              mode for operation
      InOuts:   -
      Outputs:  size:               number of bytes in the file
      PreCond:  -
      PostCond: - 
      Perms:    Query
      Throws:   NotImplemented
                IncorrectURL
                BadParameter
                DoesNotExist
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - if 'name' can be parsed as URL, but contains 
                  an invalid entry name, a 'BadParameter'
                  exception is thrown.
                - if the entry 'name' points to does not exist, 
                  a 'DoesNotExist' exception is thrown.
                - if the 'name' points to a link and the 
                  'Dereference' flag is set, the size is 
                  returned for the link target.  If that target 
                  does not exist, a 'DoesNotExist' exception is 
                  thrown.
+               - implementations MAY report directory sizes by
+                 accumulating the content sizes recursively.  
+                 If that is not implemented, a 'BadParameter' 
+                 exception with descriptive error message is 
+                 thrown.
                - the default flags are 'None' (0).
                - other flags are not allowed on this method, 
                  and cause a 'BadParameter' exception.
                - similar to the 'st_size' field from 'stat' (2)
                  as defined by POSIX
 
    - is_file
      Alias:    for is_entry in ns_directory
 
 
    Factory-like methods for creating objects:
    ------------------------------------------
 
    - open_dir
      Purpose:  creates a directory object
      Format:   open_dir           (in  url       name,
                                    in  int       flags = Read,
                                    out directory dir)
      Inputs:   name:               name of directory to open
                flags:              flags defining operation
                                    modus
      InOuts:   -
      Outputs:  dir:                opened directory instance
      PreCond:  -
      PostCond: - the session of the returned instance is that of
                  the calling instance.
                - 'Owner' of name is the id of the context
                  used to perform the operation if name gets
                  created.
      Perms:    Exec  for name's parent directory.
                Write for name's parent directory if Create is set.
                Write for name if Write is set.
                Read  for name if Read  is set.
      Throws:   NotImplemented
                IncorrectURL
                BadParameter
                AlreadyExists
                DoesNotExist
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - all notes from the ns_directory::open_dir()
                  method apply.
                - default flags are 'Read' (512).
 
 
    - open
      Purpose:  creates a new file instance
      Format:   open               (in  url       name,
                                    in  int       flags = Read,
                                    out file      file);
      Inputs:   name:               file to be opened
                flags:              flags defining operation
                                    modus
      InOuts:   -
      Outputs:  file:               opened file instance
      PreCond:  -
      PostCond: - the session of the returned instance is that of
                  the calling instance.
                - 'Owner' of name is the id of the context
                  used to perform the operation if name gets
                  created.
      Perms:    Exec  for name's parent directory.
                Write for name's parent directory if Create is set.
                Write for name if Write is set.
                Read  for name if Read  is set.
      Throws:   NotImplemented
                IncorrectURL
                BadParameter
                AlreadyExists
                DoesNotExist
                IncorrectState
                PermissionDenied
                AuthorizationFailed
                AuthenticationFailed
                Timeout
                NoSuccess
      Notes:    - all notes from the ns_directory::open() method
                  apply.
                - the file is truncated to length 0 on the open
                  operation if the 'Trunc' flag is given.
                - the file is in opened in append mode if the
                  'Append' flag is given (a seek(0, End) is
                  performed after the open).  If the 'Append'
                  flag is not given, the file pointer is
                  initially placed at the beginning of the file 
                  (a seek(0,Start) is performed after the open).
                - the 'Binary' flag is to be silently ignored on
                  systems which do not support it.
                - at least one of the flags 'Read', 'Write' or
                  'ReadWrite' must be given, otherwise a
                  'BadParameter' exception is thrown.
                - the flag set 'Read | Write' is equivalent to
                  the flag 'ReadWrite'.
                - default flags are 'Read' (512).
 \end{myspec}
 
 
 \subsubsection{Examples}
 
  Example: open a file. If its size is greater than 10, then
  read the first 10 bytes into a string, and print it.
 
 \begin{mycode}
   // c++ example
   void head (saga::url url)
   {
     try {
       // get type and other info
       saga::file f (url);
 
       off_t size = f.get_size ();
 
       if ( size > 10 )
       {
         char   buf[11];
 
         ssize_t len_out = f.read (saga::buffer (buf));
 
         if ( 10 == len_out )
         {
           std::cout << "head: "
                     << buffer.get_data ()
                     << std::endl;
         }
       }
     }
 
     // catch any possible error - see elsewhere for better
     // examples of error handling in SAGA
     catch ( const saga::exception & e )
     {
       std::cerr << "Oops! SAGA error: " 
                 << e.get_message () 
                 << std::endl;
     }
 
     return;
   }
 \end{mycode}
 
 
 
  % \subsubsection{Notes}
  % 
  %   A 'stat'-like method is not yet specified; the form of such an
  %   interface needs further consideration. However, the |'get_size()'|
  %   method provides the most frequent and well defined file size
  %   for now (the call may be deprecated when a stat specification
  %   is available).
  % 
  %   future API version may have something like:
  % 
  % \begin{myspectxt}
  %   stat             (in  url              name,
  %                     out struct           statinfo );
  % \end{myspectxt}
 
 
